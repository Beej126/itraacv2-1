using System;
using System.Windows;
using System.Windows.Controls;
using System.Data;
using System.Security.Principal;
using System.Linq;
using System.ComponentModel;
using System.Windows.Data;
using iTextSharp.text.pdf; //nugget: this thing makes PDF form filling absolutely trivial, love it, see PdfReaderand & PdfStamper usage below
using System.IO;
using System.Collections.Generic;
using System.Threading;
using System.Xml.Linq;

namespace iTRAACv2
{
  public class ReasonConfirmationArgs : EventArgs
  {
    public string Reason { get; set; }
    public bool Accept { get; set; }
  }

  public static class iTRAACHelpers
  {
    static public string FiscalYear2Chars
    {
      get
      {
        return ((DateTime.Now.Year +
          ((DateTime.Now < DateTime.Parse("10/1/" + DateTime.Now.Year.ToString())) ? 0 : 1)).ToString().Right(2));
      }
    }

    static public bool DataColumnVisible(DataColumn column)
    {
      if (column == null) return (false);

      return(
        DataColumnVisible(column.ColumnName)
        //&& (column.Expression == "") //hide columns that were slapped on with a client side expression (assuming those are special purpose)
      );
    }

    static public bool DataColumnVisible(string ColumnName)
    {
      return (ColumnName.Right(2).ToLower() != "id" /*&& ColumnName.Right(4).ToLower() != "code"*/); //hide columns with "ID" in the name
    }

    static public void WPFDataGrid_Standard_Behavior(DataGrid grid)
    {
      grid.ContextMenu = Application.Current.FindResource("WPFDataGrid_CopyMenu") as ContextMenu;
      grid.MouseRightButtonUp += new System.Windows.Input.MouseButtonEventHandler(WPFHelpers.WPFDataGrid_MouseRightButtonUp_SaveCell);
      grid.AutoGeneratingColumn += new EventHandler<DataGridAutoGeneratingColumnEventArgs>(grid_AutoGeneratingColumn);
      grid.LoadingRow += new EventHandler<DataGridRowEventArgs>(grid_LoadingRow);
    }

    static void grid_LoadingRow(object sender, DataGridRowEventArgs e)
    {
      e.Row.Header = (e.Row.GetIndex() + 1).ToString(); //nugget: easy row numbers displayed in DataGrid.Row.Header (irrespective of the active sort) via grid.LoadingRow event
    }

    static private void grid_AutoGeneratingColumn(object sender, DataGridAutoGeneratingColumnEventArgs e) //nugget:
    {
      bool Hide = false;

      DataGrid dgrid = sender as DataGrid;
      DataView dview = dgrid.ItemsSource as DataView;

      //hide column if it's used in a grouping header... 
      BindingListCollectionView bview = CollectionViewSource.GetDefaultView(dview) as BindingListCollectionView;
      if (bview !=null && bview.GroupDescriptions.Count > 0)
      {
        //this currently hard coded to simply look at the first Grouping specification to decide so that this isn't a long delay since this event gets fired for each column
        PropertyGroupDescription pg = bview.GroupDescriptions[0] as PropertyGroupDescription;
        if (pg != null && pg.PropertyName == e.PropertyName) Hide = true;
      }

      e.Column.Visibility = (( Hide 
        || !(e.PropertyDescriptor as PropertyDescriptor).IsBrowsable //recognize the [Browsable(false)] attribute, nugget: too bad the DataGrid doesn't respect this natively!?!
        || ((dview == null) ? !DataColumnVisible(e.PropertyName) : !iTRAACHelpers.DataColumnVisible(dview.Table.Columns[e.PropertyName])) //hide any columns flagged specificlaly as hidden in the model layer
        || (dgrid.Columns.Where(c => c.SortMemberPath == e.PropertyName).Count() > 0) //hide any columns that are already present (handy for having a couple predefined columns (e.g. hyperlink template) on an autogenerated columns grid)
        //(e.PropertyDescriptor.ToString() == "System.Data.DataRelationPropertyDescriptor") ) //hide autogenerated child view columns
        ) ? Visibility.Hidden : Visibility.Visible);

      e.Column.Header = (e.PropertyDescriptor as PropertyDescriptor).DisplayName; //nugget: support the [DisplayName("xyz")] attribute on Object Model Classes, too bad the DataGrid doesn't respect this natively!?!

      if (e.Column.Header.ToString().ToLower().Contains("date")) e.Column.Width = 70;
    }

  }

  public class PDFFormFiller
  {
    public PDFFormFiller(string PDFFileName, string UniqueId)
    {
      //nugget: where to store program data
      //nugget: http://blogs.msdn.com/b/cjacks/archive/2008/02/05/where-should-i-write-program-data-instead-of-program-files.aspx

      //currently under Win7, this path corresponds to "C:\Users\{username}\AppData\Local" 
      FilledPDFPath = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        Path.GetFileNameWithoutExtension(PDFFileName) + "_" + UniqueId + ".pdf");

      using (Stream PDFStream = AssemblyHelper.GetEmbeddedResource(PDFFileName.Replace(@"\", ".")))
      {
        //nugget: iTextSharp makes PDF form filling absolutely trivial, love it
        PdfReader pdfReader = new PdfReader(PDFStream);
        pdfStamper = new PdfStamper(pdfReader, new FileStream(FilledPDFPath, FileMode.Create));
        FormFields = pdfStamper.AcroFields;
      }
    }

    private PdfStamper pdfStamper = null;
    private string FilledPDFPath = null;
    private AcroFields FormFields = null;

    public void SetField(string FormFieldName, object Value)
    {
      FormFields.SetField(FormFieldName, Value.ToString());
    }

    public void Display()
    {
      // flatten the form to remove editting options...
      // set it to false to leave the form open to subsequent manual edits
      //pdfStamper.FormFlattening = false;

      pdfStamper.Close();
      pdfStamper.Dispose();

      //fire up the PDF viewer
      System.Diagnostics.Process acroreader = System.Diagnostics.Process.Start(FilledPDFPath);

      //spawn a background thread to wait for the PDF Viewer (i.e. Acrobat Reader) to be closed so PDF file can be deleted... so these files don't pile up indefinitely
      //this obviously isn't foolproof... e.g. if the user closes iTRAACv2 prior to AcroReader... but it should be pretty good
      new Thread(delegate(object filepath)
      {
        try
        {
          acroreader.WaitForExit();
          File.Delete((string)filepath);
        }
        catch (Exception ex) //this exception handler must be included as part of this pattern wherever else it's implemented
        {
          System.Windows.Threading.Dispatcher.CurrentDispatcher.Invoke((Action)delegate() { throw ex; }, null); //toss any exceptions over to the main UI thread, per MSDN direction: http://msdn.microsoft.com/en-us/library/system.windows.application.dispatcherunhandledexception.aspx
        }
      }).Start(FilledPDFPath);

    }

  }


  public class iTRAACProc : Proc
  {
    public iTRAACProc(string ProcName) : base(ProcName)
    {
      InitParms();
    }

    private void InitParms()
    {
      this["@UserGUID"] = UserModel.Current.GUID;
      this["@TaxOfficeId"] = SettingsModel.TaxOfficeId;
      this["@TaxOfficeCode"] = SettingsModel.TaxOfficeCode;
    }

    public override void ClearParms()
    {
      base.ClearParms();
      InitParms();
    }
  }

}