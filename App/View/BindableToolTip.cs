
//from here: http://agsmith.wordpress.com/2008/07/17/elementname-binding-in-tooltips-borrowing-a-namescope/

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;

// ReSharper disable CheckNamespace
public static class BindableToolTipService
// ReSharper restore CheckNamespace
{
  #region Member Variables

  private static readonly object AutoGeneratedId = new object();

  #endregion //Member Variables

  #region ToolTip
  public static object GetToolTip(DependencyObject obj)
  {
    return obj.GetValue(ToolTipProperty);
  }

  public static void SetToolTip(DependencyObject obj, object value)
  {
    obj.SetValue(ToolTipProperty, value);
  }

  public static readonly DependencyProperty ToolTipProperty =
      DependencyProperty.RegisterAttached("ToolTip", typeof(object), typeof(BindableToolTipService),
      new FrameworkPropertyMetadata(null, OnToolTipChanged));

  private static void OnToolTipChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
  {
    // clean up any old tooltip value
    if (null != e.OldValue)
    {
      var oldTT = d.GetValue(ToolTipService.ToolTipProperty) as ToolTip;

      // detach our tooltip value from the object
      d.ClearValue(ToolTipService.ToolTipProperty);

      if (null != oldTT)
      {
        NameScope.SetNameScope(oldTT, null);

        if (oldTT.Tag == AutoGeneratedId)
          oldTT.Content = null;

        oldTT.Initialized -= NewTTInitialized;
      }
    }

    // if we're getting a new tooltip then initialize the tooltip
    // property of the associated object
    if (null == e.NewValue) return;
    var newTT = e.NewValue as ToolTip ?? new ToolTip {Tag = AutoGeneratedId, Content = e.NewValue};

    // if the value isn't a tooltip then create one around it
    // so we can bind the datacontext and provide a namescope

    d.SetValue(ToolTipService.ToolTipProperty, newTT);

    // provide a temporary namescope so we can handle any element name bindings
    NameScope.SetNameScope(newTT, new NameScopeHelper(d));

    // during the BamlRecordReader's PushContext, the tooltip didn't have
    // a namescope so we need to make sure we remove the namescope before
    // the PopContext or else the reader will try to push too much off
    // the stack and an exception will occur. the Initialized event of
    // the associated element is sufficient to do this. an alternative
    // approach would be to use a custom tooltip that implements INameScope
    // so that the tooltip always has a namescope at the Push and PopContext
    // points.
    newTT.Initialized += NewTTInitialized;
  }
  #endregion //ToolTip

  #region Methods

  #region newTT_Initialized
  private static void NewTTInitialized(object sender, EventArgs e)
  {
    var tt = sender as ToolTip;
    Debug.Assert(tt != null, "tt != null");

    tt.Initialized -= NewTTInitialized;

    // see the comment in OnToolTipChanged method. we need to clear
    // the namescope to prevent the bamlrecordreader from removing too much
    // from its context stack
    NameScope.SetNameScope(tt, null);
  }
  #endregion //newTT_Initialized

  /*
  #region CreateXXXBinding
  private static Binding CreateSelfBinding(DependencyProperty property)
  {
    var b = new Binding {Path = new PropertyPath(property), RelativeSource = RelativeSource.Self};
    return b;
  }

  private static Binding CreateBinding(DependencyProperty property, object source)
  {
    var b = new Binding {Path = new PropertyPath(property), Source = source};
    return b;
  }
  #endregion //CreateXXXBinding
  */

  #endregion //Methods

  #region NameScopeHelper
  private class NameScopeHelper : INameScope
  {
    #region Member Variables

// ReSharper disable FieldCanBeMadeReadOnly.Local
    private DependencyObject _owner;
// ReSharper restore FieldCanBeMadeReadOnly.Local

    #endregion // Member Variables

    #region Constructor
    internal NameScopeHelper(DependencyObject owner)
    {
      _owner = owner;
    }
    #endregion // Constructor

    #region GetNameScope
    private INameScope GetNameScope()
    {
      var element = _owner;

      while (null != element)
      {
        INameScope nameScope = NameScope.GetNameScope(element);

        if (null != nameScope)
          return nameScope;

        element = LogicalTreeHelper.GetParent(element) ?? VisualTreeHelper.GetParent(element);
      }

      return null;
    }
    #endregion // GetNameScope

    #region INameScope Members

    object INameScope.FindName(string name)
    {
      INameScope scope = GetNameScope();

      return null != scope ? scope.FindName(name) : null;
    }

    void INameScope.RegisterName(string name, object scopedElement)
    {
      INameScope scope = GetNameScope();

      if (null != scope)
        scope.RegisterName(name, scopedElement);
    }

    void INameScope.UnregisterName(string name)
    {
      INameScope scope = GetNameScope();

      if (null != scope)
        scope.UnregisterName(name);
    }

    #endregion
  }
  #endregion //NameScopeHelper
}
